#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
    EULER 12
        The sequence of triangle numbers is generated by adding the
        natural numbers.
        So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.
        The first ten terms would be:
        1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

        Let us list the factors of the first seven triangle numbers:
             1: 1
             3: 1,3
             6: 1,2,3,6
            10: 1,2,5,10
            15: 1,3,5,15
            21: 1,3,7,21
            28: 1,2,4,7,14,28

        We can see that 28 is the first triangle number
        to have over five divisors.
        What is the value of the first triangle number
        to have over five hundred divisors?
"""
# =============================================================================
# (upper left label is the current label)
#
# SOLUTION: 76576500
#
# STATUS: [ok]
# VERIFIED: [ok]
# EXECUTION TIME: [long/ok]
# =============================================================================

from math import ceil
from math import sqrt

#def generate_triangle_numberA(): #201.9
#    index=0
#    while True:
#        index += 1
#        sumatory = sum((x for x in range(1, index+1)))
#        yield(index, sumatory)

#Si fuera por indice este tardaria mas, pero al ser acumulativos, tarda menos

#def generate_triangle_numberC(): #0.0(5) 20.5(8)
#    index=0
#    while True:
#        index += 1
#        yield(index, (index+1)*(index/2))

def generate_triangle_number(): #0.04(5) 15.8(8)
    """
    Va generando numeros triangulares
    """
    index=0
    sumatory=0
    while True:
        index += 1
        sumatory += index
        yield sumatory

def generate_triangle_numberNew():
    n=0
    while True:
        n += 1
        yield n*(n+1)/2
# =============================================================================

#def list_factors(big_number):
#    l_factors=[]
#    print("*** Iterations para {}: {}".format(big_number, ceil(big_number/2)+1))
#    for i in range(1, ceil(big_number/2)+1):
#        if(big_number%i == 0):
#            l_factors.append(i)
#    l_factors.append(big_number)
#    return l_factors, len(l_factors)



#def list_factorsB(big_number):
#    l_factors=[1,big_number]
#    print("*** Iterations para {}: {}".format(big_number, ceil(big_number/2)+1))
#    i = 2
#    while big_number != 1:
#        if(big_number % i == 0):
#            l_factors.append(i)
#            big_number = big_number / i
#            i = 2
#            continue
#        i +=1
#
#    print(l_factors)

#def list_factorsOld(big_number):
#    """
#    Dado un numero, devuelve todos sus factores 1 y big_number incluido
#    en A devuelve los factores primos
#    en B devuelve el resto
#    """
#    #l_factors = []
#    numFactors = 0
#    #print("**** numero: {}, iteraciones: {}".format(big_number, ceil(sqrt(big_number))))
#    for i in range(1, ceil(sqrt(big_number))):
#        if big_number % i == 0:
#            #l_factors.append(i) # A
#            numFactors += 1
#            if i != big_number / i:
#                #l_factors.append(int(big_number / i)) # B
#                numFactors += 1
#    #return l_factors, len(l_factors)
#    return numFactors
##76576500 -> 8751
##28 -> 6

def list_factorsNew(big_number):
    """
    Sacando los factores primos, el numero de divisores es la multiplicacion
    de los exponentes de cada factor
    2^2. 3^5 . 7^1 ==> (2+1).(5+1).(1+1)
    """
    d_factors = {}
    i = 2
    while big_number != 1:
        if big_number % i == 0:
            d_factors[i] = 1 + d_factors.get(i,0)
            big_number = big_number / i
        else:
            i +=1
    val = 1
    for key, value in d_factors.items():
        val *= value+1
    return val

#76576500 ->26 + 7
#28 -> 8


def euler12(num_factors):
    """
    Va generando numero triangulares hasta que uno de ellos tenga un numero
    de factores mayor o igual a num_factor. se para y lo pinta
    """
    it = generate_triangle_numberNew()
    return_factors = 0
    while return_factors <= num_factors:
        tn = next(it)
        #listF, return_factors = list_factors(tn)
        #print(tn)
        return_factors = list_factorsNew(tn)
    #print("Number {} Num factors {} ".format(tn, return_factors))
    return int(tn)


if __name__ == "__main__":
    print(euler12(5))
    # 28
    import time
    #timeA=time.clock()
    print(euler12(500))
    # 76576500
    timeB=time.clock()
    #print("Elapsed {} sec ".format(timeB-timeA))
